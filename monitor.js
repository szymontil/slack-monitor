// monitor.js

const { createEventAdapter } = require('@slack/events-api');
const express = require('express');
const { WebClient } = require('@slack/web-api');
const cron = require('node-cron');
const axios = require('axios');
const mongoose = require('mongoose');
const Queue = require('bull');
const dotenv = require('dotenv');
const dayjs = require('dayjs');

// ≈Åadowanie zmiennych ≈õrodowiskowych z pliku .env (tylko lokalnie)
dotenv.config();

// Sprawdzenie, czy wszystkie wymagane zmienne ≈õrodowiskowe sƒÖ ustawione
const requiredEnvVars = [
    'SLACK_SIGNING_SECRET',
    'SLACK_USER_TOKEN',
    'TARGET_USER_ID',
    'OPENAI_API_KEY',
    'TODOIST_API_KEY',
    'MONGO_URL',       
    'REDISHOST',       
    'REDISPORT',
    'REDIS_PASSWORD', 
];

requiredEnvVars.forEach((varName) => {
    if (!process.env[varName]) {
        console.error(`‚ùå Brak wymaganej zmiennej ≈õrodowiskowej: ${varName}`);
        process.exit(1);
    }
});

// Po≈ÇƒÖczenie z MongoDB
mongoose.connect(process.env.MONGO_URL, { // U≈ºycie MONGO_URL
    useNewUrlParser: true,
    useUnifiedTopology: true,
})
.then(() => console.log('‚úÖ Po≈ÇƒÖczono z MongoDB'))
.catch(err => {
    console.error('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z MongoDB:', err);
    process.exit(1);
});

// Definicja Schemat√≥w
const { Schema } = mongoose;

// Schemat wiadomo≈õci
const messageSchema = new Schema({
    channelId: { type: String, required: true },
    senderId: { type: String, required: true },
    senderName: { type: String, required: true },
    text: { type: String, required: true },
    timestamp: { type: Date, required: true },
});

// Schemat kontekstu
const contextSchema = new Schema({
    channelId: { type: String, required: true, unique: true },
    messages: [{ type: Schema.Types.ObjectId, ref: 'Message' }],
    lastActivity: { type: Date, required: true },
});

const Message = mongoose.model('Message', messageSchema);
const Context = mongoose.model('Context', contextSchema);

// Inicjalizacja Slack Events Adapter
const slackEvents = createEventAdapter(process.env.SLACK_SIGNING_SECRET);

// Inicjalizacja Express
const app = express();

// Inicjalizacja Slack WebClient z User Token
const slackClient = new WebClient(process.env.SLACK_USER_TOKEN);

// Konfiguracja kolejki z Bull z u≈ºyciem poprawionych zmiennych ≈õrodowiskowych Redis
const contextQueue = new Queue('contextQueue', {
    redis: {
        host: process.env.REDISHOST,      // Poprawiona nazwa zmiennej
        port: process.env.REDISPORT,      // Poprawiona nazwa zmiennej
        password: process.env.REDIS_PASSWORD || '', // Dodaj, je≈õli Redis wymaga has≈Ça
    },
});

// Middleware dla Slack Events Adapter - musi byƒá przed innymi middleware parsujƒÖcymi cia≈Ço ≈ºƒÖdania
app.use('/slack/events', slackEvents.expressMiddleware());

// Middleware globalny do parsowania JSON dla wszystkich innych tras
app.use(express.json());

// Funkcja do dodawania wiadomo≈õci do kontekstu
const addMessageToContext = async (channelId, message) => {
    const now = dayjs();
    let context = await Context.findOne({ channelId });

    if (context) {
        context.messages.push(message._id);
        context.lastActivity = now.toDate();
    } else {
        context = new Context({
            channelId,
            messages: [message._id],
            lastActivity: now.toDate(),
        });
    }

    await context.save();
};

// Funkcja pomocnicza do pobrania informacji o u≈ºytkowniku
const getUserInfo = async (userId) => {
    try {
        const response = await slackClient.users.info({ user: userId });
        if (response.ok) {
            return response.user;
        } else {
            console.error(`‚ùå Nie uda≈Ço siƒô pobraƒá informacji o u≈ºytkowniku: ${userId}`);
            return null;
        }
    } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas pobierania informacji o u≈ºytkowniku: ${error}`);
        return null;
    }
};

// Obs≈Çuga zdarze≈Ñ `message`
slackEvents.on('message', async (event) => {
    try {
        // Ignoruj wiadomo≈õci od bot√≥w
        if (event.bot_id) {
            return;
        }

        // Sprawdzenie, czy to wiadomo≈õƒá DM
        if (event.channel && event.channel.startsWith('D')) {
            console.log(`Received DM message in channel: ${event.channel} from user: ${event.user}`);

            // Pobranie informacji o nadawcy
            const senderInfo = await getUserInfo(event.user);
            if (!senderInfo) {
                console.log('‚ùå Nie uda≈Ço siƒô pobraƒá informacji o nadawcy.');
                return;
            }

            const senderName = senderInfo.real_name;

            // Pobranie informacji o kanale DM
            console.log(`Attempting to fetch info for channel: ${event.channel}`);
            const conversationInfo = await slackClient.conversations.info({ channel: event.channel });
            if (!conversationInfo.ok) {
                console.log(`‚ùå Nie uda≈Ço siƒô pobraƒá informacji o kanale: ${event.channel}`);
                return;
            }

            // Pobranie ID drugiej osoby w DM
            const conversationUserId = conversationInfo.channel.user;
            if (!conversationUserId) {
                console.log(`‚ùå Nie uda≈Ço siƒô pobraƒá ID drugiego u≈ºytkownika w kanale: ${event.channel}`);
                return;
            }

            const conversationUserInfo = await getUserInfo(conversationUserId);
            if (!conversationUserInfo) {
                console.log('‚ùå Nie uda≈Ço siƒô pobraƒá informacji o drugiej osobie w rozmowie.');
                return;
            }

            const conversationUserName = conversationUserInfo.real_name;

            // Okre≈õlenie, kto wys≈Ça≈Ç wiadomo≈õƒá
            const messageFrom = (event.user === process.env.TARGET_USER_ID) ? 'Szymon Til' : conversationUserName;

            // Okre≈õlenie, z kim prowadzona jest rozmowa
            const conversationWith = (event.user === process.env.TARGET_USER_ID) ? conversationUserName : 'Szymon Til';

            // Logowanie w ≈ºƒÖdanym formacie
            console.log(`Konwersacja prywatna z: ${conversationWith}`);
            console.log(`Wiadomo≈õƒá od: ${messageFrom}`);
            console.log(`Tre≈õƒá: ${event.text}\n`);

            // Zapisz wiadomo≈õƒá do bazy danych
            const message = new Message({
                channelId: event.channel,
                senderId: event.user,
                senderName: senderName,
                text: event.text,
                timestamp: new Date(parseFloat(event.ts) * 1000), // Slack timestamp jest w sekundach
            });

            await message.save();

            // Dodaj wiadomo≈õƒá do kontekstu
            await addMessageToContext(event.channel, message);
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd Slack Events API:', error);
    }
});

// Harmonogram sprawdzania nieaktywnych kontekst√≥w co 10 minut
cron.schedule('*/10 * * * *', async () => {
    console.log('üïí Sprawdzanie nieaktywnych kontekst√≥w...');
    const now = dayjs();

    try {
        const inactiveContexts = await Context.find({ lastActivity: { $lte: now.subtract(60, 'minute').toDate() } });

        for (const context of inactiveContexts) {
            console.log(`Dodawanie kontekstu do kolejki dla kana≈Çu: ${context.channelId}`);
            // Dodaj zadanie do kolejki
            await contextQueue.add({ channelId: context.channelId, contextId: context._id });
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas sprawdzania kontekst√≥w:', error);
    }
});

// Procesor kolejki
contextQueue.process(async (job) => {
    const { channelId, contextId } = job.data;
    console.log(`üîÑ Przetwarzanie kontekstu z kana≈Çu: ${channelId}`);

    try {
        const context = await Context.findById(contextId);
        if (!context) {
            console.log(`‚ùå Kontekst o ID ${contextId} nie zosta≈Ç znaleziony.`);
            return;
        }

        await processContext(channelId, context);
    } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas przetwarzania kontekstu dla kana≈Çu ${channelId}:`, error);
        throw error; // Bull bƒôdzie wiedzia≈Ç, ≈ºe zadanie nie powiod≈Ço siƒô
    }
});

// Obs≈Çuga zdarze≈Ñ kolejki
contextQueue.on('completed', (job, result) => {
    console.log(`‚úÖ Zadanie ${job.id} zako≈Ñczone sukcesem.`);
});

contextQueue.on('failed', (job, err) => {
    console.error(`‚ùå Zadanie ${job.id} zako≈Ñczy≈Ço siƒô b≈Çƒôdem:`, err);
});

// Funkcja do przetwarzania kontekstu i wysy≈Çania go do OpenAI
const processContext = async (channelId, context) => {
    try {
        // Pobierz wiadomo≈õci z bazy danych
        const messages = await Message.find({ _id: { $in: context.messages } }).sort({ timestamp: 1 });

        // Kompilacja wiadomo≈õci w kontek≈õcie
        const compiledContext = messages.map(msg => `${msg.senderName}: ${msg.text}`).join('\n');

        console.log(`üìù Przesy≈Çanie kontekstu do OpenAI dla kana≈Çu: ${channelId}`);
        console.log(compiledContext);

        // Wysy≈Çanie do OpenAI (u≈ºyj modelu GPT-4)
        const openAIResponse = await axios.post('https://api.openai.com/v1/chat/completions', {
            model: 'gpt-4', // U≈ºyj odpowiedniego modelu, np. 'gpt-4' lub 'gpt-4-0613'
            messages: [
                { role: 'system', content: 'Jeste≈õ asystentem pomagajƒÖcym identyfikowaƒá zadania z rozm√≥w.' },
                { role: 'user', content: `Przeanalizuj poni≈ºszƒÖ rozmowƒô i okre≈õl, czy zawiera ona jakie≈õ zadania do wykonania. Je≈õli tak, podaj szczeg√≥≈Çy zadania.\n\n${compiledContext}` },
            ],
            max_tokens: 150,
            temperature: 0.5,
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
            },
        });

        const analysis = openAIResponse.data.choices[0].message.content.trim();
        console.log(`üîç Analiza OpenAI:\n${analysis}`);

        // Sprawdzenie, czy OpenAI wykry≈Ço zadanie
        if (/zadanie|task/i.test(analysis)) {
            // Wyodrƒôbnij tre≈õƒá zadania
            const task = extractTask(analysis);
            if (task) {
                // Przeanalizuj, czy zadanie jest dla Ciebie
                if (isTaskForMe(task)) {
                    // Dodaj zadanie do Todoist
                    await addTaskToTodoist(task);
                    console.log('‚úÖ Zadanie zosta≈Ço dodane do Todoist.');
                }
            }
        } else {
            console.log('‚ÑπÔ∏è Brak zada≈Ñ do dodania.');
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas przetwarzania kontekstu przez OpenAI:', error.response ? error.response.data : error.message);
    }
};

// Funkcja do wyodrƒôbniania zadania z odpowiedzi OpenAI
const extractTask = (analysis) => {
    // Prosta implementacja: zak≈Çadamy, ≈ºe zadanie jest po s≈Çowie "Zadanie:" lub "Task:"
    const taskPrefixes = ['Zadanie:', 'Task:'];
    for (const prefix of taskPrefixes) {
        const index = analysis.indexOf(prefix);
        if (index !== -1) {
            return analysis.substring(index + prefix.length).trim();
        }
    }
    return null;
};

// Funkcja do okre≈õlenia, czy zadanie jest dla Ciebie
const isTaskForMe = (task) => {
    // Mo≈ºesz dodaƒá bardziej zaawansowane kryteria
    // Na przyk≈Çad, sprawdzenie, czy zadanie zawiera Twoje imiƒô lub inne identyfikatory
    return true; // Zak≈Çadamy, ≈ºe wszystkie zadania sƒÖ dla Ciebie
};

// Funkcja do dodawania zadania do Todoist
const addTaskToTodoist = async (taskContent) => {
    try {
        const todoistResponse = await axios.post('https://api.todoist.com/rest/v2/tasks', {
            content: taskContent,
            due_string: 'today', // Mo≈ºesz dostosowaƒá termin wykonania
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,
            },
        });

        console.log('‚úÖ Zadanie dodane do Todoist:', todoistResponse.data);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas dodawania zadania do Todoist:', error.response ? error.response.data : error.message);
    }
};

// Obs≈Çuga b≈Çƒôd√≥w Slack Events API
slackEvents.on('error', (error) => {
    console.error('‚ùå B≈ÇƒÖd Slack Events API:', error);
});

// Start serwera
const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
    console.log(`üöÄ Slack Events API dzia≈Ça na porcie ${PORT}`);
});
