// monitor.js

const { createEventAdapter } = require('@slack/events-api');
const express = require('express');
const { WebClient } = require('@slack/web-api');
const cron = require('node-cron');
const axios = require('axios');
const mongoose = require('mongoose');
const Queue = require('bull');
const dotenv = require('dotenv');
const dayjs = require('dayjs');

// ≈Åadowanie zmiennych ≈õrodowiskowych
dotenv.config();

// Konfiguracja limit√≥w dla plik√≥w
const FILE_SIZE_LIMIT = 10 * 1024 * 1024; // 10MB w bajtach

// Na poczƒÖtku pliku po importach
dotenv.config();

// Sprawdzenie wymaganych zmiennych ≈õrodowiskowych
const requiredEnvVars = [
    'SLACK_SIGNING_SECRET',
    'SLACK_USER_TOKEN',
    'TARGET_USER_ID',
    'OPENAI_API_KEY',
    'TODOIST_API_KEY',
    'MONGO_URL',
    'REDIS_URL',  // Zamiast REDISHOST i REDISPORT u≈ºywamy REDIS_URL
];

// Sprawdzenie zmiennych ≈õrodowiskowych
const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
    console.error('‚ùå Brak wymaganych zmiennych ≈õrodowiskowych:');
    missingVars.forEach(varName => {
        console.error(`   - ${varName}`);
    });
    process.exit(1);
} else {
    console.log('‚úÖ Wszystkie wymagane zmienne ≈õrodowiskowe sƒÖ ustawione');
}

// Po≈ÇƒÖczenie z MongoDB
mongoose.connect(process.env.MONGO_URL)
    .then(() => console.log('‚úÖ Po≈ÇƒÖczono z MongoDB'))
    .catch(err => {
        console.error('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z MongoDB:', err);
        process.exit(1);
    });

// Definicja Schemat√≥w
const { Schema } = mongoose;

// Schemat wiadomo≈õci
const messageSchema = new Schema({
    channelId: { type: String, required: true },
    senderId: { type: String, required: true },
    senderName: { type: String, required: true },
    text: { type: String, required: true },
    timestamp: { type: Date, required: true, index: true },
    files: [{
        id: String,
        title: String,
        filetype: String,
        url_private: String,
        permalink: String,
        thumb_360: String,
        original_w: Number,
        original_h: Number,
        mimetype: String,
        content: Buffer,
        size: Number,
        tooLarge: { type: Boolean, default: false }
    }]
});

// Schemat kontekstu
const contextSchema = new Schema({
    channelId: { type: String, required: true, unique: true },
    messages: [{ type: Schema.Types.ObjectId, ref: 'Message' }],
    lastActivity: { type: Date, required: true, index: true }
});

// Dodanie indeks√≥w
messageSchema.index({ timestamp: 1 });
contextSchema.index({ lastActivity: 1 });

const Message = mongoose.model('Message', messageSchema);
const Context = mongoose.model('Context', contextSchema);

// Inicjalizacja Express i Slack
const slackEvents = createEventAdapter(process.env.SLACK_SIGNING_SECRET);
const app = express();
const slackClient = new WebClient(process.env.SLACK_USER_TOKEN);

// Konfiguracja kolejki Redis dla Railway
const contextQueue = new Queue('contextQueue', {
    redis: process.env.REDIS_URL, // U≈ºywamy pe≈Çnego URL zamiast osobnych host/port
    defaultJobOptions: {
        attempts: 3,
        backoff: {
            type: 'exponential',
            delay: 1000
        },
        removeOnComplete: true,
        removeOnFail: false
    },
    limiter: {
        max: 1000,
        duration: 5000
    }
});

// Konfiguracja obs≈Çugi b≈Çƒôd√≥w i monitorowania
contextQueue.on('error', (error) => {
    console.error('‚ùå B≈ÇƒÖd kolejki Redis:', error);
    // Nie ko≈Ñczymy procesu przy b≈Çƒôdzie Redis - aplikacja mo≈ºe dzia≈Çaƒá dalej
});

contextQueue.on('failed', (job, error) => {
    console.error(`‚ùå Zadanie ${job.id} nie powiod≈Ço siƒô:`, error);
});

// Funkcja do sprawdzania czy Redis jest wymagany dla danej operacji
function isRedisRequired(operation) {
    return ['processContext', 'addToQueue'].includes(operation);
}

// Funkcja do bezpiecznego dodawania zada≈Ñ do kolejki
async function safelyAddToQueue(data) {
    try {
        return await contextQueue.add(data);
    } catch (error) {
        console.error('‚ùå Nie mo≈ºna dodaƒá zadania do kolejki Redis:', error);
        // Tutaj mo≈ºemy dodaƒá alternatywnƒÖ logikƒô, np. zapis do bazy
        return null;
    }
}

// Funkcja do sprawdzania stanu Redis
async function checkRedisConnection() {
    try {
        const client = contextQueue.client;
        await client.ping();
        console.log('‚úÖ Po≈ÇƒÖczenie z Redis dzia≈Ça prawid≈Çowo');
        return true;
    } catch (error) {
        console.error('‚ùå Problem z po≈ÇƒÖczeniem Redis:', error);
        return false;
    }
}

// Okresowe sprawdzanie stanu Redis
setInterval(async () => {
    await checkRedisConnection();
}, 60000); // co minutƒô

// Sprawd≈∫ po≈ÇƒÖczenie przy starcie
checkRedisConnection();

// Middleware
app.use('/slack/events', slackEvents.expressMiddleware());
app.use(express.json());

// Funkcje pomocnicze
function isFileTooLarge(fileInfo) {
    return fileInfo.size > FILE_SIZE_LIMIT;
}

async function processSlackFile(fileInfo) {
    try {
        if (isFileTooLarge(fileInfo)) {
            console.log(`‚ö†Ô∏è Plik ${fileInfo.title} jest zbyt du≈ºy (${(fileInfo.size / 1024 / 1024).toFixed(2)}MB > ${FILE_SIZE_LIMIT / 1024 / 1024}MB)`);
            return {
                id: fileInfo.id,
                title: fileInfo.title,
                filetype: fileInfo.filetype,
                url_private: fileInfo.url_private,
                permalink: fileInfo.permalink,
                thumb_360: fileInfo.thumb_360,
                original_w: fileInfo.original_w,
                original_h: fileInfo.original_h,
                mimetype: fileInfo.mimetype,
                size: fileInfo.size,
                tooLarge: true
            };
        }

        const response = await axios({
            method: 'GET',
            url: fileInfo.url_private,
            headers: {
                'Authorization': `Bearer ${process.env.SLACK_USER_TOKEN}`
            },
            responseType: 'arraybuffer'
        });

        return {
            id: fileInfo.id,
            title: fileInfo.title,
            filetype: fileInfo.filetype,
            url_private: fileInfo.url_private,
            permalink: fileInfo.permalink,
            thumb_360: fileInfo.thumb_360,
            original_w: fileInfo.original_w,
            original_h: fileInfo.original_h,
            mimetype: fileInfo.mimetype,
            content: response.data,
            size: response.data.length,
            tooLarge: false
        };
    } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas pobierania pliku ${fileInfo.title}:`, error);
        return {
            id: fileInfo.id,
            title: fileInfo.title,
            filetype: fileInfo.filetype,
            url_private: fileInfo.url_private,
            permalink: fileInfo.permalink,
            thumb_360: fileInfo.thumb_360,
            original_w: fileInfo.original_w,
            original_h: fileInfo.original_h,
            mimetype: fileInfo.mimetype,
            size: fileInfo.size,
            tooLarge: false
        };
    }
}

async function addMessageToContext(channelId, message) {
    const now = dayjs();
    let context = await Context.findOne({ channelId });

    if (context) {
        context.messages.push(message._id);
        context.lastActivity = now.toDate();
    } else {
        context = new Context({
            channelId,
            messages: [message._id],
            lastActivity: now.toDate(),
        });
    }

    await context.save();
}

async function getUserInfo(userId) {
    try {
        const response = await slackClient.users.info({ user: userId });
        return response.ok ? response.user : null;
    } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas pobierania informacji o u≈ºytkowniku: ${error}`);
        return null;
    }
}

// Obs≈Çuga wiadomo≈õci
slackEvents.on('message', async (event) => {
    try {
        if (event.bot_id) {
            return;
        }

        if (event.channel && event.channel.startsWith('D')) {
            console.log(`Received DM message in channel: ${event.channel} from user: ${event.user}`);

            const senderInfo = await getUserInfo(event.user);
            if (!senderInfo) {
                console.log('‚ùå Nie uda≈Ço siƒô pobraƒá informacji o nadawcy.');
                return;
            }

            const senderName = senderInfo.real_name;

            console.log(`Attempting to fetch info for channel: ${event.channel}`);
            const conversationInfo = await slackClient.conversations.info({ channel: event.channel });
            if (!conversationInfo.ok) {
                console.log(`‚ùå Nie uda≈Ço siƒô pobraƒá informacji o kanale: ${event.channel}`);
                return;
            }

            const conversationUserId = conversationInfo.channel.user;
            if (!conversationUserId) {
                console.log(`‚ùå Nie uda≈Ço siƒô pobraƒá ID drugiego u≈ºytkownika w kanale: ${event.channel}`);
                return;
            }

            const conversationUserInfo = await getUserInfo(conversationUserId);
            if (!conversationUserInfo) {
                console.log('‚ùå Nie uda≈Ço siƒô pobraƒá informacji o drugiej osobie w rozmowie.');
                return;
            }

            const messageFrom = (event.user === process.env.TARGET_USER_ID) ? 'Szymon Til' : conversationUserInfo.real_name;
            const conversationWith = conversationUserInfo.real_name;

            let messageText = event.text || '';
            let files = [];

            if (event.files && event.files.length > 0) {
                console.log(`üìé Przetwarzanie ${event.files.length} plik√≥w...`);
                
                files = await Promise.all(event.files.map(file => processSlackFile(file)));

                files.forEach(file => {
                    if (file.tooLarge) {
                        console.log(`‚ö†Ô∏è Plik ${file.title} pominiƒôty (zbyt du≈ºy): ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    } else if (!file.content) {
                        console.log(`‚ö†Ô∏è Plik ${file.title} nie zosta≈Ç pobrany (b≈ÇƒÖd pobierania)`);
                    } else {
                        console.log(`‚úÖ Plik ${file.title} zapisany: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    }
                });

                if (!messageText) {
                    messageText = `[Wys≈Çano ${files.length} ${files.length === 1 ? 'plik' : 'pliki'}: ${files.map(f => f.filetype).join(', ')}]`;
                }
            }

            console.log(`Konwersacja prywatna z: ${conversationWith}`);
            console.log(`Wiadomo≈õƒá od: ${messageFrom}`);
            console.log(`Tre≈õƒá: ${messageText}\n`);

            const message = new Message({
                channelId: event.channel,
                senderId: event.user,
                senderName: senderName,
                text: messageText,
                timestamp: new Date(parseFloat(event.ts) * 1000),
                files: files
            });

            await message.save();
            await addMessageToContext(event.channel, message);
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd Slack Events API:', error);
    }
});

// Harmonogram czyszczenia bazy
async function cleanupDatabase() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);

    try {
        const result = await Message.deleteMany({
            timestamp: { $lt: yesterday }
        });
        console.log(`üßπ Usuniƒôto ${result.deletedCount} starych wiadomo≈õci`);

        const contextResult = await Context.deleteMany({
            lastActivity: { $lt: yesterday }
        });
        console.log(`üßπ Usuniƒôto ${contextResult.deletedCount} starych kontekst√≥w`);

    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas czyszczenia bazy:', error);
    }
}

// Uruchamianie czyszczenia codziennie o p√≥≈Çnocy
cron.schedule('0 0 * * *', async () => {
    console.log('üïê Rozpoczynanie codziennego czyszczenia bazy...');
    await cleanupDatabase();
});

// Harmonogram sprawdzania nieaktywnych kontekst√≥w co 10 minut
cron.schedule('*/10 * * * *', async () => {
    console.log('üïí Sprawdzanie nieaktywnych kontekst√≥w...');
    const now = dayjs();

    try {
        // Znajd≈∫ konteksty nieaktywne od godziny
        const inactiveContexts = await Context.find({ 
            lastActivity: { $lte: now.subtract(60, 'minute').toDate() } 
        });

        for (const context of inactiveContexts) {
            console.log(`Dodawanie kontekstu do kolejki dla kana≈Çu: ${context.channelId}`);
            await safelyAddToQueue({ 
                channelId: context.channelId, 
                contextId: context._id 
            });
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas sprawdzania kontekst√≥w:', error);
    }
});

// Obs≈Çuga kolejki kontekst√≥w
contextQueue.process(async (job) => {
    const { channelId, contextId } = job.data;
    console.log(`üîÑ Przetwarzanie kontekstu z kana≈Çu: ${channelId}`);

    try {
        const context = await Context.findById(contextId);
        if (!context) {
            console.log(`‚ùå Kontekst o ID ${contextId} nie zosta≈Ç znaleziony.`);
            return;
        }

        await processContext(channelId, context);
    } catch (error) {
        console.error(`‚ùå B≈ÇƒÖd podczas przetwarzania kontekstu dla kana≈Çu ${channelId}:`, error);
        throw error;
    }
});

// Obs≈Çuga zdarze≈Ñ kolejki
contextQueue.on('completed', (job) => {
    console.log(`‚úÖ Zadanie ${job.id} zako≈Ñczone sukcesem.`);
});

contextQueue.on('failed', (job, err) => {
    console.error(`‚ùå Zadanie ${job.id} zako≈Ñczy≈Ço siƒô b≈Çƒôdem:`, err);
});

// Funkcja do przetwarzania kontekstu i wysy≈Çania go do OpenAI
const processContext = async (channelId, context) => {
    try {
        const messages = await Message.find({ _id: { $in: context.messages } }).sort({ timestamp: 1 });
        const compiledContext = messages.map(msg => `${msg.senderName}: ${msg.text}`).join('\n');

        console.log(`üìù Przesy≈Çanie kontekstu do OpenAI dla kana≈Çu: ${channelId}`);
        console.log(compiledContext);

        const openAIResponse = await axios.post('https://api.openai.com/v1/chat/completions', {
            model: 'gpt-4',
            messages: [
                { role: 'system', content: 'Jeste≈õ asystentem pomagajƒÖcym identyfikowaƒá zadania z rozm√≥w.' },
                { role: 'user', content: `Przeanalizuj poni≈ºszƒÖ rozmowƒô i okre≈õl, czy zawiera ona jakie≈õ zadania do wykonania. Je≈õli tak, podaj szczeg√≥≈Çy zadania.\n\n${compiledContext}` },
            ],
            max_tokens: 150,
            temperature: 0.5,
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
            },
        });

        const analysis = openAIResponse.data.choices[0].message.content.trim();
        console.log(`üîç Analiza OpenAI:\n${analysis}`);

        if (/zadanie|task/i.test(analysis)) {
            const task = extractTask(analysis);
            if (task && isTaskForMe(task)) {
                await addTaskToTodoist(task);
                console.log('‚úÖ Zadanie zosta≈Ço dodane do Todoist.');
            }
        } else {
            console.log('‚ÑπÔ∏è Brak zada≈Ñ do dodania.');
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas przetwarzania kontekstu przez OpenAI:', error.response ? error.response.data : error.message);
    }
};

// Funkcja do wyodrƒôbniania zadania z odpowiedzi OpenAI
const extractTask = (analysis) => {
    const taskPrefixes = ['Zadanie:', 'Task:'];
    for (const prefix of taskPrefixes) {
        const index = analysis.indexOf(prefix);
        if (index !== -1) {
            return analysis.substring(index + prefix.length).trim();
        }
    }
    return null;
};

// Funkcja do okre≈õlenia, czy zadanie jest dla Ciebie
const isTaskForMe = (task) => {
    // Mo≈ºesz dodaƒá bardziej zaawansowane kryteria
    return true; // Na razie zak≈Çadamy, ≈ºe wszystkie zadania sƒÖ dla nas
};

// Funkcja do dodawania zadania do Todoist
const addTaskToTodoist = async (taskContent) => {
    try {
        const todoistResponse = await axios.post('https://api.todoist.com/rest/v2/tasks', {
            content: taskContent,
            due_string: 'today',
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,
            },
        });

        console.log('‚úÖ Zadanie dodane do Todoist:', todoistResponse.data);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas dodawania zadania do Todoist:', error.response ? error.response.data : error.message);
    }
};

// Obs≈Çuga b≈Çƒôd√≥w Slack Events API
slackEvents.on('error', (error) => {
    console.error('‚ùå B≈ÇƒÖd Slack Events API:', error);
});

// Start serwera
const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
    console.log(`üöÄ Slack Events API dzia≈Ça na porcie ${PORT}`);
});